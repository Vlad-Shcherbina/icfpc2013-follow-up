from nose.tools import eq_

from terms import *


def test_to_str():
    eq_(term_to_str(0), '0')
    eq_(term_to_str((LAMBDA, ('x',), (PLUS, 'x', (NOT, '1')))),
        '(lambda (x) (plus x (not 1)))')
    pass


def test_eval():
    eq_(evaluate((PLUS, 'x', 1), dict(x=42)), 43)

    eq_(evaluate((IF0, 0, 1, 0)), 1)
    eq_(evaluate((IF0, 1, 1, 0)), 0)

    eq_(apply_lambda(
            (LAMBDA, ('x',),
                (FOLD, 'x', 0, (LAMBDA, ('y', 'z'), (OR, 'y', 'z')))),
            {},
            0x1122334455667788),
        0x00000000000000ff)


def test_eval_from_file():
    with open('../data/eval_tests') as fin:
        tests = eval(fin.read())
        for _, _, program, pairs in tests:
            program = eval(program)
            for x, y in pairs:
                eq_(apply_lambda(program, {}, x), y)


def test_size():
    eq_(term_size(0), 1)
    eq_(term_size((LAMBDA, ('x', ), 'x')), 2)
    eq_(term_size((PLUS, 0, 1)), 3)
    eq_(term_size((FOLD, 0, 1, (LAMBDA, ('x', 'y'), 0))), 5)


def test_op():
    eq_(term_op(0), set())
    eq_(term_op((LAMBDA, ('x',), (PLUS, 'x', (NOT, '1')))),
        set([PLUS, NOT]))


def test_subst():
    eq_(subst((PLUS, 1, 0), {1:2}), (PLUS, 2, 0))


def test_parse_term():
    tests = [
            '1',
            '(plus x 1)',
            '(lambda (x_77708) (fold (and (shr4 (not (shr16 (shr16 (shr1 (shr4 (plus (if0 (shr1 (plus (xor (xor 0 (not x_77708)) 1) x_77708)) x_77708 1) 1))))))) x_77708) x_77708 (lambda (x_77709 x_77710) (if0 x_77709 x_77710 x_77709))))',
            '(lambda (x_79511) (fold (xor (shr4 (shl1 (shr4 (or (if0 (xor x_79511 (or (shr4 (and (shl1 (plus x_79511 (shr4 x_79511))) x_79511)) x_79511)) 1 x_79511) x_79511)))) x_79511) 0 (lambda (x_79512 x_79513) (plus (shr16 x_79513) x_79512))))',
            '(lambda (x_78077) (fold (not (plus (shr16 (shl1 (or (or (plus (plus (if0 (plus (plus (shl1 x_78077) 0) x_78077) 0 x_78077) 1) x_78077) 1) 1))) x_78077)) x_78077 (lambda (x_78078 x_78079) (plus x_78078 (shr1 x_78079)))))',
            '(lambda (x_85865) (fold x_85865 0 (lambda (x_85865 x_85866) (or x_85865 (if0 (xor (shl1 (plus x_85865 (xor (plus (shr16 (and x_85865 (not (plus (xor (or x_85866 x_85865) x_85865) x_85866)))) x_85865) x_85866))) x_85866) 0 x_85865)))))',
            ]
    for t in tests:
        eq_(term_to_str(parse_term(t)), t)


def make_number_term(x):
    if x in [0, 1]:
        return x
    if x % 2 == 0:
        return (SHL1, make_number_term(x//2))
    else:
        return (PLUS, (SHL1, make_number_term(x//2)), 1)


if __name__ == '__main__':
    import random
    from pprint import pprint
    from communicate import eval_program

    import logging
    logging.basicConfig(level=logging.INFO)

    random.seed(42)

    hz = 0x1001010081010011  # not too many ones, or program would be too large
    hz_term = make_number_term(hz)

    xs = [0, 1, 2**4, 2**16, 2**32, 2**63, 2**64-1]
    xs += [random.randrange(2**64) for _ in range(10)]

    interesting_terms = []
    interesting_terms.append(hz)
    for op in UNARY_OPS:
        interesting_terms.append((op, 'x'))
    for op in BINARY_OPS:
        interesting_terms.append((op, 'x', hz))
        interesting_terms.append((op, hz, 'x'))

    interesting_terms.append((IF0, 'x', 1, 0))

    fold_op = (LAMBDA, ('y', 'z'), (XOR, (SHL1, 'y'), 'z'))
    interesting_terms.append((FOLD, 'x', hz, fold_op))

    print 'generating eval tests based on server output...'
    tests = []
    for i, term in enumerate(interesting_terms):
        print i, 'of', len(interesting_terms)
        print term
        program = (LAMBDA, ('x',), subst(term, {hz: hz_term}))
        ys = eval_program(term_to_str(program), xs)
        test = (term, term_to_str(term), repr(program), zip(xs, ys))
        tests.append(test)

    with open('../data/eval_tests', 'w') as fout:
        print>>fout, '# generated by terms_test.py'
        pprint(tests, stream=fout)

    print 'done'
